[day07]

변수
연산자	화폐매수 구하기
if	짝수 홀수
for	구구단 전체 ~ 별찍기 10번
배열	1차원 배열 최솟값 최대값,정렬, 아파트 6번



1. 객체 지향
	# 객체 지향 
	# 특징
		코드 재사용성이 높다 : API 사용
		코드 관리가 쉽다 : 상속, 다형성 , 추상화 , 캡슐화 ............
		신뢰성이 높은 프로그램 개발 가능
		
	# 캡슐화 (encapsulation) : 자바가 지향하는 코드 스타일.
	# 상속(inheritance)	: 부모의 속성을 자식 클래스가 상속받음
	# 다형성 (polymorphism) : 상속 관계에서 성립	(매우 중요)
		같은 이름의 기능이 클래스나 객체에 따라 다르게 동작하도록 구현되는 것

2. 클래스 와 객체
	
	1) 클래스 (설계도)
		객체를 정의해 놓은것
		용도는 객체를 만들기 위한 것
		
	2) 객체
		실제로 존재하는 것.
		클래스 모양(설계) 그대로 생성된 실체

	3) 객체와 인스턴스
		객체 == 인스턴스
		
	4) 객체 : 속성 + 기능				속성+기능 = 멤버
		속성과 기능을 통틀어 멤버라고 부른다.
		속성 : 멤버변수, 필드 (명사)
		기능 : 메소드 (동사형)

	5) 객체 생성과 사용
		
		#1. 클래스 정의

		* 클래스 구조 *
		class 클래스명 {
			변수
			메소드		// 속성이나 기능
		}
		
		# 클래스명은 첫글자 대문자, 숫자로 시작X, 띄어쓰기X, 특수기호 _$ 만 허용
		   패키지내 클래스명은 한개만 존재해야함.

		#2. 객체 생성
		** 선언 **
		클래스명 참조변수명;	//	String str;
		** 생성 **
		참조변수명 = new 클래스명();
		
		** 선언 + 생성 **
		클래스명 참조변수명 = new 클래스명();
		Scanner sc = new Scanner(); 
			
		참조 변수( 레퍼런스 변수 ) : 객체를 가르키는, 객체의 주소(레퍼런스)를 담고 있을 변수 or 배열
		new : 클래스 모양의 메모리를 점유하는 문법적으로 중요한 키워드 (heap memory를 점유)
		(레퍼런스 치환도 가능)
	
		#3. 객체 사용 :  점( . ) 연산자를 사용하여 변수나 기능을 부름

		참조변수명.변수 = 값;
		참조변수명.메소드();		

	-> 정리
	클래스 == 사용자 정의 데이터 타입
		기본형 : 메모리양이 정해진것.
		클래스 : 개발자가 필요한 만큼 메모리 크기를 직접 지정해서 만든것.
	클래스 :  유사한 특징을 지닌 객체들의 속성과 기능을 묶어 놓은 집합

3.  변수의 종류
	: 선언 위치 (어디서 변수가 만들어졌느냐)에 따라 변수의 종류와 성질이 달라짐.

	1) 클래스 변수 ( static 변수 )
		= 선언 위치 : 클래스 안 (메소드 밖)
		= 이름앞에 static 키워드 붙는다

		= 종류 : 클래스 기본형 변수 / 클래스 참조형 변수
		= 특징 : 모든 객체들이 공유하는 변수*
			프로그램 시작하면 먼저 로딩되고,
			new로 객체생성하지 않아도 바로 사용가능. *		
		= 접근 방법
			클래스명.변수명 	<----(static 붙으면) (추천하는 방식)*
			참조변수명.변수명

	2) 인스턴스 변수
		= 클래스 안 생성 (메소드 밖)		
		= 종류 : 인스턴스 기본형 변수 / 인스턴스 참조형 변수
		= 특징 : 각 객체(인스턴스) 의 개별적인 저장공간을 갖는다.*
			new~ 로 객체생성한 후 메모리가 점유되면 사용가능.*
			가르키는 참조변수가 없을 경우 가비지 컬렉터가 수거해감.
			또는 프로그램 종료시 소멸됨.
		= 접근 방법 
			참조변수명.변수명


	3) 지역변수
		= 메소드 안 생성
		= 종류 : 지역 기본형 변수 / 지역 참조형 변수
		= 특징 : 메소드(조건문,반복문) 내에서 선언된 변수를 가르키며,
			메소드 종료시 소멸

	# 메모리 로딩순서
	클래스 ->  static -> main 실행 -> (new~~) 인스턴스 생성
	| 클래스 범위 만들고
		| static 붙은 아이들 모두 로딩
			| main 있다면 실행
				| new로 객체 생성된 아이들 생성
